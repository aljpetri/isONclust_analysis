#this snakemake pipeline is used to analyse the performance of isONform,
#especially on bigger datasets (>1k reads)
#This is done by aligning all isoforms to the reference as well as aligning all original reads to the reference. We than can compare the counts of isoforms by comparing nr_occs and 

#Runnable the script by using the following: snakemake --cores 1 --configfile configs.json
#to change the isoform abundance: Change isONform call in full_pipeline.sh (this is located in the isONform folder itself)
#The following variables represent the paths to the files required to run this pipeline

###File_location: Gives the location of the files that we want to analyse:
#file_location="/home/alexanderpetri/isONform_analysis/100kSIRV/0againer/"
file_location=config["REFERENCE_FOLDER"]

###Script_input_folder: Equal to the folder the snakefile is located in. Should also contain all scripts needed for our analysis:
#script_input_folder="/home/alexanderpetri/isONform_analysis/Evaluation/Evaluate_SIRV/"
script_input_folder=config["SCRIPT_FOLDER"]

### Output_folder: The folder in which all intermediate datasets as well as all real outputs are stored:
#output_folder="/home/alexanderpetri/isONform_analysis/Analysis/SIRVtest/"
output_folder=config["OUTPUT_FOLDER"]

###ref_folder: Path to the reference which we use to analyse the data
#ref_folder="/home/alexanderpetri/Desktop/RAWDATA_PhD1/100kSIRVSubsampling/"
ref_folder=config["REFERENCE_FOLDER"]

minimap_out_folder=config["MINIMAP_OUT_FOLDER"]

IDS, = glob_wildcards(file_location+'spoa{id}merged.fa')
#python get_error_rates_original.py SIRVTranscriptome.fasta 100kvsOriginal.sam analyse_100k_reads.csv
#python count_SIRV_id_occurrences.py analyse_100k_reads.csv out.csv
isonform_location=config["ISONFORM_LOCATION"]
#snakemake_out_folder=config["RATTLE_OUT_FOLDER"]
#rattle_location=config["RATTLE_SCRIPT_FOLDER"]
#isonform_outfolder=config["ISONFORM_OUT_FOLDER"]




minimap_out_folder=config["MINIMAP_OUT_FOLDER"]
ref_folder=config["REFERENCE_FOLDER"]
isonclust_out_folder=config["ISONCLUST_OUT_FOLDER"]
output_folder = config["OUTPUT_FOLDER"]
rule all:
	input: output_folder+"result_py_isONclust.txt",output_folder+"result_rs_isONclust.txt",minimap_out_folder +"alignment.bam", minimap_out_folder+"alignment.sorted.bam.bai"#, snakemake_out_folder+'rattle_counts.csv',output_folder+'dummy.txt', isonform_outfolder+'/isONformAnalysis.csv',output_folder+"alignments/results_ison.csv"#,output_folder+"alignments/results_rattle.csv"#,output_folder+'dummy.txt'
		#snakemake_out_folder+"clusters.out"
		
###############################################################################################################################
#                                                Alignment PIPELINE                                                           #
###############################################################################################################################


##Align the original reads to the reference via minimap2 
rule align_original_reads_minimap2:
    input: 	reference = ref_folder + 'non_redundant_SIRVTranscriptome.fasta',
    	   	original_reads = ref_folder + 'full_length_output.fastq'	 #outfolder_root+'/data/full_length_output.fastq'
    output: 	alignment =  minimap_out_folder +'alignment.bam'
    run:
            	shell("minimap2 --t 8 --ax splice --uf --k14 {input.reference} {input.original_reads} >{output.alignment} ")


##Sort the alignment
rule sort_alignment:
	input: minimap_out_folder+"alignment.bam"
	output: minimap_out_folder+"alignment.sorted.bam"
	shell: "samtools view -Su {input} | samtools sort -o {output}"

##Index the alignment(StringtiePipe)
rule index_alignment:
	input: minimap_out_folder+"alignment.sorted.bam"
	output: minimap_out_folder+"alignment.sorted.bam.bai"
	shell: "samtools index {input}"	
		
rule compute_quality_py:
	input: 	py_cluster = isonclust_out_folder + "final_clusters_py.tsv",
			alignment = minimap_out_folder+"alignment.bam"
			#rs_cluster = isonclust_out_folder + "final_clusters_100k_annot.tsv"
	output:	output_folder+"result_py_isONclust.txt"
	shell: "python compute_cluster_quality.py --clusters {input.py_cluster} --classes {input.alignment} --outfile {output}"
		
rule compute_quality_rs:
	input: 	rs_cluster = isonclust_out_folder + "final_clusters_100k_annot.tsv",
			alignment = minimap_out_folder+"alignment.bam"		
	output:	output_folder+"result_rs_isONclust.txt"
	shell: "python compute_cluster_quality.py --clusters {input.rs_cluster} --classes {input.alignment} --outfile {output}"		
		
		
#The following rules are used to get a minimap based isoform count of our inputfile
#rule pychop:
#	input: file_location+'100k_sample.fastq'
#	output: file_location+'full_length_output.fastq'
#	shell: 'pychopper {input} {output}'

#rule minimap_alignment:
#	input: ref=ref_folder+'non_redundant_SIRVTranscriptome.fasta', reads=file_location+'full_length_output.fastq'
#	output: minimap_out_folder+'100kvsOriginal.sam'
#	shell: 'minimap2 -ax map-ont --eqx {input.ref} {input.reads} > {output}'

#rule minimap_alignment_parse:
#	input: ref_folder+'non_redundant_SIRVTranscriptome.fasta', minimap_out_folder+'100kvsOriginal.sam'
#	output: minimap_out_folder+'analyse_100k_reads.csv'
#	shell:'python get_error_rates_original.py {input} {output}'





