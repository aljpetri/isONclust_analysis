#this snakemake pipeline is used to analyse the performance of isONform,
#especially on bigger datasets (>1k reads)
#This is done by aligning all isoforms to the reference as well as aligning all original reads to the reference. We than can compare the counts of isoforms by comparing nr_occs and 
# first activate environment:   conda activate clustering
#Runnable the script by using the following: snakemake --cores 1 --configfile configs.json
#to change the isoform abundance: Change isONform call in full_pipeline.sh (this is located in the isONform folder itself)
#The following variables represent the paths to the files required to run this pipeline

###File_location: Gives the location of the files that we want to analyse:

file_location=config["REFERENCE_FOLDER"]

###Script_input_folder: Equal to the folder the snakefile is located in. Should also contain all scripts needed for our analysis:
script_input_folder=config["SCRIPT_FOLDER"]

### Output_folder: The folder in which all intermediate datasets as well as all real outputs are stored:
output_folder=config["OUTPUT_FOLDER"]

###ref_folder: Path to the reference which we use to analyse the data
ref_folder=config["REFERENCE_FOLDER"]

minimap_out_folder=config["MINIMAP_OUT_FOLDER"]

IDS, = glob_wildcards(file_location+'spoa{id}merged.fa')

isonform_location=config["ISONFORM_LOCATION"]
#snakemake_out_folder=config["RATTLE_OUT_FOLDER"]
#rattle_location=config["RATTLE_SCRIPT_FOLDER"]
#isonform_outfolder=config["ISONFORM_OUT_FOLDER"]




minimap_out_folder=config["MINIMAP_OUT_FOLDER"]
ref_folder=config["REFERENCE_FOLDER"]
isonclust_out_folder=config["ISONCLUST_OUT_FOLDER"]
output_folder = config["OUTPUT_FOLDER"]
rule all:
	input: output_folder+"result_rs_isONclust_annot.txt",output_folder+"result_rs_isONclust_denovo.txt"#, output_folder + "result_GeLuster.txt",output_folder+"result_py_isONclust.txt",
	#,minimap_out_folder +"alignment.bam", minimap_out_folder+"alignment.sorted.bam.bai"#, snakemake_out_folder+'rattle_counts.csv',output_folder+'dummy.txt', isonform_outfolder+'/isONformAnalysis.csv',output_folder+"alignments/results_ison.csv"#,output_folder+"alignments/results_rattle.csv"#,output_folder+'dummy.txt'
		#snakemake_out_folder+"clusters.out"

###############################################################################################################################
#                                                Clustering steps                                                             #
###############################################################################################################################

##Run the python version of isONclust
rule cluster_python:
    input:	fastq = ref_folder + 'full_length_output.fastq'
    output: 	output_folder+'output_py/final_clusters.tsv'
    run:
        py_output_folder=output_folder+'output_py',
        outfolder=output_folder+'output_py/clustering/fastq_files',
        shell("time -p isONclust  --t 8  --ont --fastq {input.fastq} --outfolder {py_output_folder}"),
        shell("time -p isONclust write_fastq --N 1 --clusters {output} --fastq {input.fastq} --outfolder {outfolder}")

##Run the rust version of isONclust for annotation
rule cluster_rs_annot:
    input: fastq = ref_folder + 'full_length_output.fastq'
    output: output_folder+'output_rs_annot/clustering/final_clusters.tsv'
    run:	
        outfolder=output_folder+'output_rs_annot',
        initial_clustering="~/Desktop/RAWDATA_PhD1/100kSIRVSubsampling/SIRV_isoforms_multi-fasta_170612a.fasta",
        gff= "~/Desktop/RAWDATA_PhD1/100kSIRVSubsampling/SIRV.gff3",
        shell("time -p cargo run --release --manifest-path ~/Rust/isONclust_rs/Cargo.toml -- --fastq {input.fastq} --gff {gff} --mode ont --outfolder {outfolder} --init-cl {initial_clustering}")

##Run the rust version of isONclust for denovo
rule cluster_rs_denovo:
    input: fastq = ref_folder + 'full_length_output.fastq'
    output: output_folder+'output_rs_denovo/clustering/final_clusters.tsv'
    run:	
        outfolder=output_folder+'output_rs_denovo',
        shell("time -p cargo run --release --manifest-path ~/Rust/isONclust_rs/Cargo.toml --  --fastq {input.fastq}   --outfolder {outfolder} --mode ont")
	
	
rule run_GeLuster:
    input: fastq = ref_folder + 'full_length_output.fastq'
    output: output_folder+'GeLuster/GeLuster.tsv'
    run:
        outfolder=output_folder+'GeLuster'
        shell("time -p /home/alexanderpetri/GeLuster/GeLuster -r {input.fastq}  -f fq -s cDNA -o {outfolder}")
###############################################################################################################################
#                                                Alignment PIPELINE                                                           #
###############################################################################################################################


##Align the original reads to the reference via minimap2 
rule align_original_reads_minimap2:
    input: 	reference = ref_folder + 'SIRV_isoforms_multi-fasta_170612a.fasta',
    	   	original_reads = ref_folder + 'full_length_output.fastq'	 
    output: 	alignment =  minimap_out_folder +'alignment.bam'
    run:
            	shell("minimap2 -t 8 -ax splice -uf -k 14 {input.reference} {input.original_reads} >{output.alignment} ")


##Sort the alignment
rule sort_alignment:
	input: minimap_out_folder+"alignment.bam"
	output: minimap_out_folder+"alignment.sorted.bam"
	shell: "samtools view -Su {input} | samtools sort -o {output}"

##Index the alignment(StringtiePipe)
rule index_alignment:
	input: minimap_out_folder+"alignment.sorted.bam"
	output: minimap_out_folder+"alignment.sorted.bam.bai"
	shell: "samtools index {input}"	
		
###############################################################################################################################
#                                                Cluster quality assessment                                                   #
###############################################################################################################################		
		
rule compute_quality_py:
	input: 	py_cluster = output_folder + 'output_py/final_clusters.tsv',
			alignment = minimap_out_folder + "alignment.sorted.bam",
			index = minimap_out_folder + "alignment.sorted.bam.bai"
			#rs_cluster = isonclust_out_folder + "final_clusters_100k_annot.tsv"
	output:	output_folder + "result_py_isONclust.txt"
	shell: "python compute_cluster_quality.py --clusters {input.py_cluster} --classes {input.alignment} --outfile {output} --modified_ont"
		
rule compute_quality_rs_annot:
	input: 	rs_cluster = output_folder + 'output_rs_annot/clustering/final_clusters.tsv',
			alignment = minimap_out_folder + "alignment.sorted.bam",
			index = minimap_out_folder + "alignment.sorted.bam.bai"		
	output:	output_folder + "result_rs_isONclust_annot.txt"
	shell: "python compute_cluster_quality.py --clusters {input.rs_cluster} --classes {input.alignment} --outfile {output} "		
		

rule compute_quality_rs_denovo:
	input: 	rs_cluster = output_folder + 'output_rs_denovo/clustering/final_clusters.tsv',
			alignment = minimap_out_folder + "alignment.sorted.bam",
			index = minimap_out_folder + "alignment.sorted.bam.bai"		
	output:	output_folder + "result_rs_isONclust_denovo.txt"
	shell: "python compute_cluster_quality.py --clusters {input.rs_cluster} --classes {input.alignment} --outfile {output} "	

rule compute_quality_geluster:
	input: 	rs_cluster = output_folder + 'GeLuster/GeLuster.tsv',
			alignment = minimap_out_folder + "alignment.sorted.bam",
			index = minimap_out_folder + "alignment.sorted.bam.bai"		
	output:	output_folder + "result_GeLuster.txt"
	shell: "python compute_cluster_quality_geluster.py --clusters {input.rs_cluster} --classes {input.alignment} --outfile {output}"	
	
			
#The following rules are used to get a minimap based isoform count of our inputfile
#rule pychop:
#	input: file_location+'100k_sample.fastq'
#	output: file_location+'full_length_output.fastq'
#	shell: 'pychopper {input} {output}'

#rule minimap_alignment:
#	input: ref=ref_folder+'non_redundant_SIRVTranscriptome.fasta', reads=file_location+'full_length_output.fastq'
#	output: minimap_out_folder+'100kvsOriginal.sam'
#	shell: 'minimap2 -ax map-ont --eqx {input.ref} {input.reads} > {output}'

#rule minimap_alignment_parse:
#	input: ref_folder+'non_redundant_SIRVTranscriptome.fasta', minimap_out_folder+'100kvsOriginal.sam'
#	output: minimap_out_folder+'analyse_100k_reads.csv'
#	shell:'python get_error_rates_original.py {input} {output}'





